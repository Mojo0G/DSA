{
  "metadata": {
    "totalProblems": 7,
    "lastUpdated": "2025-08-26T17:14:48.234Z",
    "breakdown": {
      "Codechef": {
        "total": 1,
        "Easy": 1,
        "Medium": 0,
        "Hard": 0
      },
      "Gfg": {
        "total": 0,
        "Easy": 0,
        "Medium": 0,
        "Hard": 0
      },
      "Leetcode": {
        "total": 5,
        "Easy": 1,
        "Medium": 2,
        "Hard": 2
      },
      "Hackerrank": {
        "total": 1,
        "Easy": 0,
        "Medium": 1,
        "Hard": 0
      }
    }
  },
  "problems": [
    {
      "id": "codechef-easy-search-an-element-in-an-array",
      "platform": "Codechef",
      "difficulty": "Easy",
      "problemName": "Search an element in an array",
      "language": "java",
      "files": {
        "code": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\nclass Codechef\n{\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\t// your code goes here\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int x = sc.nextInt();\n        \n        boolean isfound = false;\n        \n        for (int i = 0;i < n ;i++ ){\n            int ce = sc.nextInt();\n            if(ce == x){\n                isfound = true;\n            }\n        }\n        \n        if (isfound){\n            System.out.println(\"YES\");\n        }\n        else{\n            System.out.println(\"NO\");\n        }\n        \n        sc.close();\n\t}\n}",
        "readme": "Search an element in an array\n\nYou are given an array \nð´\nA of size \nð‘\nN and an element \nð‘‹\nX. Your task is to find whether the array \nð´\nA contains the element \nð‘‹\nX or not.\n\nInput Format\nThe first line contains two space-separated integers \nð‘\nN and \nð‘‹\nX â€” the size of array and the element to be searched.\nThe second line contains all the elements of array \nð´\nA\nOutput Format\n\nOutput \"YES\" if the element \nð‘‹\nX is present in \nð´\nA, otherwise output \"NO\".\n\nConstraints\n1\nâ‰¤\nð‘\nâ‰¤\n10\n5\n1â‰¤Nâ‰¤10\n5\n1\nâ‰¤\nð´\nð‘–\nâ‰¤\n10\n5\n1â‰¤A\ni\n\tâ€‹\n\nâ‰¤10\n5\nSample 1:\nInput\nOutput\n5 3\n7 3 5 2 1\nYES\nSample 2:\nInput\nOutput\n5 10\n7 3 5 2 1\nNO",
        "notes": "# Search an element in an array\n\n          **Summary:** This code implements a solution using Java. It processes data through iterative operations and appears to solve the given problem efficiently.\n\n          - Time Complexity: O(n)\n          - Space Complexity: O(1)"
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-26T17:14:48.064Z"
    },
    {
      "id": "hackerrank-medium-simple-array-sum",
      "platform": "Hackerrank",
      "difficulty": "Medium",
      "problemName": "Simple Array Sum",
      "language": "java",
      "files": {
        "code": "import java.io.*;\nimport java.math.*;\nimport java.security.*;\nimport java.text.*;\nimport java.util.*;\nimport java.util.concurrent.*;\nimport java.util.function.*;\nimport java.util.regex.*;\nimport java.util.stream.*;\nimport static java.util.stream.Collectors.joining;\nimport static java.util.stream.Collectors.toList;\n\nclass Result {\n\n    /*\n     * Complete the 'simpleArraySum' function below.\n     *\n     * The function is expected to return an INTEGER.\n     * The function accepts INTEGER_ARRAY ar as parameter.\n     */\n\n    public static int simpleArraySum(List<Integer> ar) {\n    // Write your code here\n    int sum = 0;\n    for (int num : ar) {\n        sum += num;\n    }\nreturn sum;\n    }\n\n}\n\npublic class Solution {\n    public static void main(String[] args) throws IOException {\n        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(\"OUTPUT_PATH\")));\n\n        int arCount = Integer.parseInt(bufferedReader.readLine().trim());\n\n        List<Integer> ar = Stream.of(bufferedReader.readLine().replaceAll(\"\\\\s+$\", \"\").split(\" \"))\n            .map(Integer::parseInt)\n            .collect(toList());\n\n        int result = Result.simpleArraySum(ar);\n\n        bufferedWriter.write(String.valueOf(result));\n        bufferedWriter.newLine();\n\n        bufferedReader.close();\n        bufferedWriter.close();\n    }\n}",
        "readme": "Given an array of integers, find the sum of its elements.\n\nFor example, if the array , , so return .\n\nFunction Description\n\nComplete the  function with the following parameter(s):\n\n: an array of integers\n\nReturns\n\n: the sum of the array elements\n\nInput Format\n\nThe first line contains an integer, , denoting the size of the array.\nThe second line contains  space-separated integers representing the array's elements.\n\nConstraints\n\nSample Input\n\nSTDIN           Function\n-----           --------\n6               ar[] size n = 6\n1 2 3 4 10 11   ar = [1, 2, 3, 4, 10, 11]\n\n\nSample Output\n\n31\n\n\nExplanation\n\nPrint the sum of the array's elements: .",
        "notes": "# Simple Array Sum\n\n          **Summary:** This code implements a solution using Java 15. It processes data through iterative operations and appears to solve the given problem efficiently.\n\n          - Time Complexity: O(n)\n          - Space Complexity: O(1)"
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-26T17:14:48.077Z"
    },
    {
      "id": "leetcode-easy-two-sum",
      "platform": "Leetcode",
      "difficulty": "Easy",
      "problemName": "Two Sum",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n         Map<Integer, Integer> mp = new HashMap<>();\n\n        for (int i = 0; i < nums.length; i++) {\n            mp.put(nums[i], i );\n        }\n        //mycode\n        int[] res = new int[2];\n\n        for (int i = 0; i < nums.length; i++) {\n            \n            int later = target - nums[i];\n            if (mp.containsKey(later) && mp.get(later) != i) {\n                res = new int[]{i, mp.get(later)};\n                break;\n            }\n        }\n\n        return res;\n    }\n}",
        "readme": "Given an array of integers numsÂ and an integer target, return indices of the two numbers such that they add up to target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nYou can return the answer in any order.\n\nÂ \nExample 1:\n\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n\n\nExample 2:\n\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n\n\nExample 3:\n\nInput: nums = [3,3], target = 6\nOutput: [0,1]\n\n\nÂ \nConstraints:\n\n\n\t2 <= nums.length <= 104\n\t-109 <= nums[i] <= 109\n\t-109 <= target <= 109\n\tOnly one valid answer exists.\n\n\nÂ \nFollow-up:Â Can you come up with an algorithm that is less than O(n2)Â time complexity?",
        "notes": "# Two Sum\n\n          **Summary:** This Java code uses a HashMap to solve the Two Sum problem. It first populates the HashMap with array elements as keys and their indices as values. Then, it iterates through the array; for each element, it checks if the complement (target - element) exists in the HashMap. If the complement exists and its index is different from the current element's index, it means a pair adding up to the target has been found. The indices of this pair are returned. Otherwise, the loop continues until a pair is found or the loop completes.\n\n          - Time Complexity: O(n) because the code iterates through the input array once to populate the HashMap and then iterates through it again at most once to find the pair.  HashMap operations (put and containsKey) take constant time on average.\n          - Space Complexity: O(n) because the HashMap stores at most n key-value pairs, where n is the length of the input array. The space used by other variables is constant."
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-26T17:14:48.069Z"
    },
    {
      "id": "leetcode-medium-container-with-most-water",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Container With Most Water",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public int maxArea(int[] height) {\n       \n        int i = 0, j = height.length - 1;\n        int max = 0;\n\n        while (i < j) {\n            \n            int water = Math.min(height[i],height[j])*(j-i);\n\n            max = max < water? water: max;\n\n            if (height[i] <= height[j]) {\n                i++;\n            }\n            else{\n                j--;\n            }\n        }\n        return max;  \n    }\n}",
        "readme": "11. Container With Most WaterSolvedMediumTopicsCompaniesHintYou are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\n\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\n\nReturn the maximum amount of water a container can store.\n\nNotice that you may not slant the container.\n\nÂ \nExample 1:\n\nInput: height = [1,8,6,2,5,4,8,3,7]\nOutput: 49\nExplanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\n\n\nExample 2:\n\nInput: height = [1,1]\nOutput: 1\n\n\nÂ \nConstraints:\n\n\n\tn == height.length\n\t2 <= n <= 105\n\t0 <= height[i] <= 104\n\nÂ Seen this question in a real interview before?1/5YesNoAccepted4,385,734/7.5MAcceptance Rate58.2%TopicsArrayTwo PointersGreedyCompaniesHint 1If you simulate the problem, it will be O(n^2) which is not efficient.Hint 2Try to use two-pointers. Set one pointer to the left and one to the right of the array. Always move the pointer that points to the lower line.Hint 3How can you calculate the amount of water at each step?Similar QuestionsTrapping Rain WaterHardMaximum Tastiness of Candy BasketMediumHouse Robber IVMediumDiscussion (642)Choose a typeCommentðŸ’¡ Discussion Rules1. Please don't post any solutions in this discussion.2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there.Sort by:BestJean BarkhuysenOct 30, 2017This question is exceptionally unclear. Anyone else having that trouble?Â Read more1.2K21halleknastNov 01, 2016The current formulation of the problem doesn't make any sense. After having seen the solution, I've found the following clarification to be needed:\nForget about water; that only confuses things. The problem is just about finding a maximum area rectangle. The water formulation made me think that for there to be a container, all lines between the container ends must be lower than the ends. I didn't get to see examples of this not being the case because my solution timed out.\nAlso, the formulation doesn't tell what the function should actually return. A more correct formulation would thus be something like:\n\"[...]. All pairs of the n lines define a rectangle with a height given by the shorter line and a width given by the distance between the lines. Return the area of the rectangle with the largest area.\"Â Read more91531shiva97Aug 18, 2021The proof of why the solution works is important to understand. Following is its summary:\n\nConsider we start with i = 0 and j = height.size() - 1. That is, i points to the first column and j points to the last column.\nNow suppose that h(i)>h(j) (we are not loosing generality by this assumption)\nWe calculate the water capacity for the i, j. It will be h(j)*(j-i).\nNow see that if we fix j at height.size() - 1 and vary i, we cannot get a greater water capacity. Why?\n\ncapacity = min of both heights * width between them. Since capacity is the product of these two terms, we will look at each term individually.\nFirst about the width. It is easy to see that for all other i's (i = 1, 2,... ,height.size()-2) we will have a lesser width.\nSecond, the height will be the minimum of the column at i and at j, i.e. min(h(i),h(j)). But this value will be always less than h(j)\nSo both factors in the calculation of the capacity will be smaller and hence we can skip considering all the cases where i = 1, 2, 3, ..., height.size()-2 and j = height.size()-1\nWhich basically means that we can simply move j to j-1.\n\n\n\nThis is how I understood it and I hope this explanation makes it easy to understand.Â Read more53833waitingtodieOct 27, 2017Whoever designed this problem has no ability whatsoever to speak in plain English.Â Read more5525alec_csJun 05, 2021Some of these proofs are not very clear. I want to expand on Steven Pochmann's idea and hopefully make it clearer.\nExplanation\n\nTo start, we place both pointers at the beginning and end of the array. While this is common with most two pointer approaches, in this specific problem it allows us to consider all potential possibilities. Thus, in a way we are still brute forcing the solution, however we are carefully optimizing the possibilities at each iteration so that the optimal solution is not missed.\nAt each iteration, no matter what, the width will decrease. This is because we must move either the left and right pointer. Therefore, we must consider the potential outcomes after we either increase the left pointer or decrease the right pointer.\n\nOutcome A: If we decrease a pointer and the height of the pillar is smaller than the previous height (where the pointer was originally before we moved it), the overall area will have to be smaller. This is because we take the minumum of the two heights that the pointers are pointing at, and because the width will be decreased by 1, the new area will have to be the same or smaller.\nOutcome B: If we decrease a pointer and the height of the pillar is larger or the same as the previous height, the width may or may not be larger than the previous height, because it depends on whether the height difference between the new pillar and the previous pillar can compensate for the loss of width.\n\n\n\nSo why do we always move the pointer of the smallest pillar?\nThe reason for this is simple. There is no reason to hang onto the pillar of the smallest size in the current range because in the next iteration, the overall width will decrease by one. Thus, a potential greater area will never be reached by hanging onto the smaller pillar, because even if another taller pillar is found by moving the pointer at the taller pillar, the area must always be calculated with the minimum of the two pillars. Due to the smaller width by decreasing the pointer range, the overall area will be smaller regardless. Thus, we can safely disregard the smaller pillar at each iteration.Â Read more25617Yang  ZhaoSep 28, 2018This is a formal proof of the O(n) algorithm mentioned in the tutorial.\nProblem Description:\nCondition: We have two pointers at i & j, suppose h[i] <= h[j].\nGoal to Prove: If there is a better answer within the sub-range of [i, j], then the range [i + 1, j] must contain that optimal sub-range. (This doesn't mean range [i, j - 1] can't contain it, we just want to prove range [i + 1, j] will contain it).\nProof:\nSince we assume there is a better answer in the sub-range of [i, j], then this optimal range must be contained by either [i + 1, j] or [i, j - 1], or both.\nLet's assume [i + 1, j] doesn't contain the optimal range, but [i, j - 1] contains it. Then this means two things:\n\nthe optimal range is not in [i + 1, j - 1], otherwise, [i + 1, j] will contain it.\nThe optimal range contains the block [i, i + 1] (since this is the part which exists in [i, j - 1] but not in [i+1, j]).\n\nHowever, notice that, len(i, j - 1) < len(i, j), and in the range [i, j], the area is constrained by the height of h[i] (even in the case h[i] == h[j]). Thus, in the range [i, j - 1], even all pillar are no shorter than h[j], the maximum area is smaller than the area formed by i & j, which contradicts our assumption there is a better answer in the sub-range of [i, j]. This contradiction suggests [i + 1, j] contains the optimal sub-range, if such sub-range exists.\nAccording to above theorem, we can design the algorithm, whenever h[i] < h[j], we advance the pointer i.Â Read more23912bvelardeMar 29, 2021Isn't it obvious that 8x8 will hold more water than the 7x7 implied in the expected answer?Â Read more22121labrador_peninsulaMay 09, 2022Algorithm:\n\nDesignate two pointers ptr_lo = 0 and ptr_hi = length(height) - 1 i.e. set the two pointers at the two ends.\nIf height[ptr_lo] <= height[ptr_hi] then increment ptr_lo.\nIf height[ptr_lo] > height[ptr_hi] then decrement ptr_hi (i.e. iteratively move the smaller of the two edges closer to the other).\nCalculate the area after each change and keep track of the maximum area.\nEnd when the two pointers are equal to each other.\n\nWhy the algorithm works\nLet i, j be the left and right edges of the container with most water (0 <= i < j < length(height)). If there are multiple such containers, then i, j can be the edges of any one of them. We will prove that between the start and end condition, there must be one moment when ptr_lo == i and ptr_hi == j i.e. the maximum area is always considered.\n\n\nNote that between the start and end condition, there must be a pointer that reaches one of the edge of the maximum container (the dashed border in our figure). We can now devise three scenarios:\nScenario 1: ptr_lo == i and ptr_hi == j at the same time\nThis means we proved our hypothesis.\nScenario 2: ptr_lo reaches the left edge first\nHere, we have ptr_lo == i and j < ptr_hi < length(height). We can now have two sub-scenarios:\nSub-scenario 1 If height[ptr_hi] >= height[ptr_lo] i.e. the right edge >= left edge\n\nIn this situation, we see that by letting  height[ptr_hi] >= height[ptr_lo], we create a new area strictly greater than the maximum area. This contradicts our original stipulation. Therefore, sub-scenario 1 is impossible.\nSub-scenario 2 If height[ptr_lo] > height[ptr_hi] i.e. the left edge > right edge\n\nUsing the algorithm, we will just keep decrementing ptr_hi. In fact, because sub-scenario 1 is impossible, once ptr_lo == i, then for all j < ptr_hi < length(height) we have height[ptr_lo] > height[ptr_hi].\nTherefore, once ptr_lo reaches i, it will stays there until ptr_hi reaches j. We proved our hypothesis\nScenario 3: ptr_hi reaches the right edge first\nThis is the same as scenario 2, only reversed.\nHope this helps.Â Read more887Sachi Nandan PradhanSep 06, 2023just disgusting test casesÂ Read more59summerbleachMay 10, 2024Notice that you may not slant the container.\nNo one is even trying that, why the notice?Â Read moreFeedback565123465Copyright Â© 2025 LeetCode. All rights reserved.",
        "notes": "# Container With Most Water\n\n          **Summary:** This code implements a solution using Java. It processes data through iterative operations and appears to solve the given problem efficiently.\n\n          - Time Complexity: O(n)\n          - Space Complexity: O(1)"
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-26T17:14:48.071Z"
    },
    {
      "id": "leetcode-medium-find-first-and-last-position-of-element-in-sorted-array",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Find First and Last Position of Element in Sorted Array",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public int[] searchRange(int[] nums, int target) {\n        int[] ans = { -1, -1 };\n        int start = search(nums, target, true);\n        int end = search(nums, target, false);\n        ans[0] = start;\n        ans[1] = end;\n        return ans;\n    }\n\n    static int search(int[] num, int target, boolean firstindex) {\n        int ans = -1;\n        int start = 0;\n        int end = num.length - 1;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (num[mid] > target) {\n                end = mid - 1;\n            } else if (num[mid] < target) {\n                start = mid + 1;\n            } else {\n                ans = mid;\n                if (firstindex) {\n                    end = mid - 1;\n                } else {\n                    start = mid + 1;\n                }\n            }\n        }\n        return ans;\n    }\n}",
        "readme": "34. Find First and Last Position of Element in Sorted ArraySolvedMediumTopicsCompaniesGiven an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.\n\nIf target is not found in the array, return [-1, -1].\n\nYou mustÂ write an algorithm withÂ O(log n) runtime complexity.\n\nÂ \nExample 1:\nInput: nums = [5,7,7,8,8,10], target = 8\nOutput: [3,4]\nExample 2:\nInput: nums = [5,7,7,8,8,10], target = 6\nOutput: [-1,-1]\nExample 3:\nInput: nums = [], target = 0\nOutput: [-1,-1]\n\nÂ \nConstraints:\n\n\n\t0 <= nums.length <= 105\n\t-109Â <= nums[i]Â <= 109\n\tnums is a non-decreasing array.\n\t-109Â <= targetÂ <= 109\n\nÂ Seen this question in a real interview before?1/5YesNoAccepted2,853,998/6MAcceptance Rate47.3%TopicsArrayBinary SearchCompaniesSimilar QuestionsFirst Bad VersionEasyPlates Between CandlesMediumFind Target Indices After Sorting ArrayEasyDiscussion (313)Choose a typeCommentðŸ’¡ Discussion Rules1. Please don't post any solutions in this discussion.2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there.Sort by:BestSatvik ShrivastavaJul 14, 2023After attempting this binary search is running through my veins.Â Read more36212Tasneem AyhamOct 09, 2023Guys, just for better experience to our fellow LeetCoders, if you find a problem that's ranked medium/hard and you think it should be levelled down, please refrain from writing it in the discussion section as that would demoralize our brothers/sisters. Remember, we were all in their place once!!\nThank you for your understanding!Â Read more4662Joe NgJan 16, 2022I sometimes get 5th percentile speed from a submission, then a 95th percentile speed on the next with the exact same code.Â Read more17114Moonbeam8773Apr 17, 2023I'm sorry. What is \"sorted in non-decreasing order\"? Isn't that just sorted in ascending order?Â Read more18714PrishaOct 09, 2023When you first encounter this question, your initial instinct might be to employ a simple O(N) solution, where you traverse the array to locate both the first and last positions of the target element. After all, it seems like a straightforward approach, right? ðŸ¤”\nHowever, here's where the plot thickens!\nGiven that the array is sorted, why not leverage this fact to your advantage and craft a logarithmic solution instead?  The term \"sorted\" practically whispers to you, suggesting the use of binary search. But how exactly do you wield this powerful technique?\nðŸ¤” Ah, here's the twist! The main challenge arises when the element you're looking for equals nums[mid]. Is it the first occurrence or the last? ðŸ¤·â€â™€ï¸ That's the million-dollar question right there.\nâœ¨ Now, here comes the magic trick!\nYou don't just use one binary search; you utilize two of them. ðŸª„ Yes, you heard that right!\nOne binary search is dedicated to finding the lower bound, and the other to discover the upper bound.\nðŸŽ¯ And just like that, you've transformed a seemingly complex problem into an elegant, efficient solution. Ta-da! ðŸŽ‰âœ¨ðŸ’«Â Read more2337mstuebsOct 09, 2023Don't submit code that is not thoroughly tested. Make sure to have additional test cases, like\n[]\n42\n[7,8,8,8,8,8,8,8,8,8,8,9]\n7\n[7,8,8,8,8,8,8,8,8,8,8,9]\n8\n[7,8,8,8,8,8,8,8,8,8,8,9]\n10\n[1,2,2,2,2,3,4,5,5,5,5,6,7,8,9,10,11,12,12,12,12,12,13]\n2\n[-999985131,-999953607,-999953607,-999915742,-999883817,-999849817,-999822901,-999815377,-999810801,-68594,-49967,20394,114012,999969829,999973689,999975494]\n-999953607\nhttps://github.com/mquintus/l33tcode-testcase-generator/blob/main/generated/34_Find_First_and_Last_Position_of_Element_in_Sorted_Array.txtÂ Read more616heijinganghuashengNov 16, 2013If the elements of the whole array is the same as the target, can we do it in a O(logn) time?Â Read more6013M Mahbubul AlamJan 19, 2023At first use binary search. When your mid value will be equal to the target, then use two different binary search on the left part and right part of the mid.Â Read moreTip847WizelDec 07, 2022Why in the case the nums is [1] , target is 1, the search result should be [0, 0] ?Â Read more349Shubham JhaNov 22, 2022previous UI was much handyÂ Read more231123432Copyright Â© 2025 LeetCode. All rights reserved.",
        "notes": "# Find First and Last Position of Element in Sorted Array\n\n          **Summary:** The code utilizes two arrays: the input `nums` array and an `ans` array to store the start and end indices of the target.  It employs a binary search algorithm (`search` function) twice: once to find the leftmost occurrence (firstindex = true) and again to find the rightmost occurrence (firstindex = false) of the target.  The `search` function iteratively narrows the search space until the target is found, adjusting the search bounds based on whether it's searching for the first or last occurrence.\n\n          - Time Complexity: O(log n). The binary search algorithm is used, which has a time complexity of O(log n), where n is the length of the input array. The algorithm performs binary search twice, but the overall time complexity remains O(log n).\n          - Space Complexity: O(1). The algorithm uses a constant amount of extra space, regardless of the input size. The space used by the `ans` array and the variables within the `search` function is constant."
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-26T17:14:48.072Z"
    },
    {
      "id": "leetcode-hard-median-of-two-sorted-arrays",
      "platform": "Leetcode",
      "difficulty": "Hard",
      "problemName": "Median of Two Sorted Arrays",
      "language": "cpp",
      "files": {
        "code": "class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        // Get the sizes of both input arrays.\n        int n = nums1.size();\n        int m = nums2.size();\n\n        // Merge the arrays into a single sorted array.\n        vector<int> merged;\n        for (int i = 0; i < n; i++) {\n            merged.push_back(nums1[i]);\n        }\n        for (int i = 0; i < m; i++) {\n            merged.push_back(nums2[i]);\n        }\n\n        // Sort the merged array.\n        sort(merged.begin(), merged.end());\n\n        // Calculate the total number of elements in the merged array.\n        int total = merged.size();\n\n        if (total % 2 == 1) {\n            // If the total number of elements is odd, return the middle element as the median.\n            return static_cast<double>(merged[total / 2]);\n        } else {\n            // If the total number of elements is even, calculate the average of the two middle elements as the median.\n            int middle1 = merged[total / 2 - 1];\n            int middle2 = merged[total / 2];\n            return (static_cast<double>(middle1) + static_cast<double>(middle2)) / 2.0;\n        }\n    }\n};",
        "readme": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\n\nThe overall run time complexity should be O(log (m+n)).\n\nÂ \nExample 1:\n\nInput: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.\n\n\nExample 2:\n\nInput: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n\n\nÂ \nConstraints:\n\n\n\tnums1.length == m\n\tnums2.length == n\n\t0 <= m <= 1000\n\t0 <= n <= 1000\n\t1 <= m + n <= 2000\n\t-106 <= nums1[i], nums2[i] <= 106",
        "notes": "# Median of Two Sorted Arrays\n\n          **Summary:** The code uses vectors (dynamic arrays) to store and manipulate input and merged arrays. It first merges two input sorted arrays into a single vector, then sorts the merged vector. Finally, it determines the median based on whether the total number of elements is odd or even, returning the middle element or the average of the two middle elements, respectively.\n\n          - Time Complexity: O(m+n+k log k), where m and n are the lengths of input arrays and k = m+n. This is because merging takes O(m+n), sorting takes O(k log k), and the rest of the operations are O(1). In the worst-case scenario, where both input arrays are unsorted, the sorting step dominates.\n          - Space Complexity: O(m+n), because a new vector 'merged' of size m+n is created to store the combined elements of the two input arrays. This is a linear space complexity."
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-26T17:14:48.074Z"
    },
    {
      "id": "leetcode-hard-permutation-sequence",
      "platform": "Leetcode",
      "difficulty": "Hard",
      "problemName": "Permutation Sequence",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public String getPermutation(int n, int k) {\n        // Validation\n        int totalPermutations = factorial(n);\n        if (k < 1 || k > totalPermutations) {\n            throw new IllegalArgumentException(\n                \"k must be between 1 and \" + totalPermutations + \", got \" + k\n            );\n        }\n\n        // Prepare numbers 1..n\n        List<Integer> numbers = new ArrayList<>();\n        for (int i = 1; i <= n; i++) {\n            numbers.add(i);\n        }\n\n        // Precompute factorials\n        int[] facts = new int[n + 1];\n        facts[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            facts[i] = facts[i - 1] * i;\n        }\n\n        // Build the k-th permutation\n        StringBuilder permutation = new StringBuilder();\n        // Convert k to 0-based index\n        int kIndex = k - 1;\n\n        for (int pos = n; pos >= 1; pos--) {\n            int fact = facts[pos - 1];\n            int idx = kIndex / fact;\n            permutation.append(numbers.get(idx));\n            numbers.remove(idx);\n            kIndex %= fact;\n\n            // Debug info\n            System.out.println(\n                \"Select \" + permutation.charAt(permutation.length() - 1) +\n                \" from remaining: \" + numbers +\n                \" (Block size: \" + fact + \", kIndex: \" + kIndex + \")\"\n            );\n        }\n\n        return permutation.toString();\n    }\n\n    /**\n     * Computes n! (factorial).\n     */\n    private int factorial(int n) {\n        int prod = 1;\n        for (int i = 2; i <= n; i++) {\n            prod *= i;\n        }\n        return prod;\n    }\n}",
        "readme": "60. Permutation SequenceSolvedHardTopicsCompaniesThe set [1, 2, 3, ...,Â n] contains a total of n! unique permutations.\n\nBy listing and labeling all of the permutations in order, we get the following sequence for n = 3:\n\n\n\t\"123\"\n\t\"132\"\n\t\"213\"\n\t\"231\"\n\t\"312\"\n\t\"321\"\n\n\nGiven n and k, return the kth permutation sequence.\n\nÂ \nExample 1:\nInput: n = 3, k = 3\nOutput: \"213\"\nExample 2:\nInput: n = 4, k = 9\nOutput: \"2314\"\nExample 3:\nInput: n = 3, k = 1\nOutput: \"123\"\n\nÂ \nConstraints:\n\n\n\t1 <= n <= 9\n\t1 <= k <= n!\n\nÂ Seen this question in a real interview before?1/5YesNoAccepted501,964/993.3KAcceptance Rate50.5%TopicsMathRecursionCompaniesSimilar QuestionsNext PermutationMediumPermutationsMediumDiscussion (73)Choose a typeCommentðŸ’¡ Discussion Rules1. Please don't post any solutions in this discussion.2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there.Sort by:BestPiyush RajMar 15, 2024A simple hint for this question\nIt doesnt need backtracking nor recursion to solve. You can solve it using factorials and some basic intuition really. Just generate the kth permutation directly!\nIf you need further hint here it is\nLets say i have 5 numbers [1,2,3,4,5] and n = 17 well my first thought would be, what can be the 1st digit in my permutation? If we are talking lexicographically sorted permutations then the first number will change to 2 from 1 after (4)! iterations (because there are 4 numbers after 1 in the list) but we see 4!  > 17 thus what can we conclude from this?\nTry to think about it and you would be able to come up with an algorithm to solve it without backtracking or recursion.Â Read moreTip603joeleetcode2018Oct 11, 2018The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!Â Read more654CGKJul 02, 2023Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passedÂ Read more151JulienApr 02, 2023The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\nI mean, it's a good thing that the brute force doesn't pass, but why do I get different results when I test that individually ?Â Read more143noob_2347Apr 14, 2023Can someone tell me why is this hard?Â Read more2714Shaik Aman SayerJun 11, 2023Hardest question i ever solvedÂ Read more12Dipanjan SahaApr 07, 2025this was the first hard question I solved all by myself :)Â Read more111Jinsheng ZhouAug 07, 2016Even if I ad this line:\nif(n ==8 && k == 8590) return \"26847351\";\nI still got TLE...Â Read more142ChandlerNov 30, 2016I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly.Â Read more73Martin ShoostermanMay 19, 2023Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there.Â Read more5212348Copyright Â© 2025 LeetCode. All rights reserved.",
        "notes": "# Permutation Sequence\n\n          **Summary:** This code implements a solution using Java. It processes data through iterative operations and appears to solve the given problem efficiently.\n\n          - Time Complexity: O(nï¿½)\n          - Space Complexity: O(1)"
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-26T17:14:48.075Z"
    }
  ]
}